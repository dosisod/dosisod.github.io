<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="" />
  <link rel="stylesheet" href="/styles/main.css">
  <link rel="stylesheet" href="/styles/gruvbox-dark-hard.css" />
  <title>Writing a Compiler: Before You Start</title>
</head>
<body>

<main>
<h1>Writing a Compiler: Before You Start</h1>
<br>
<blockquote>Note: I assume that you have a basic understanding of programming languages,
how they work, and how to do all of the basics (functions, control flow,
building/running programs, etc). It doesn't matter which language, just so
long as you have a basic grasp.</blockquote>
<br>
<p>There are a lot of reasons why you might want to write your own compiler:</p>
<br>
<ul>
<li>You want to make your own programming language</li>
<li>You want to port an existing language to a new platform</li>
<li>You want to learn the magic that goes into creating/running your code or executables</li>
</ul>
<br>
<p>All of these are good goals and aspirations. A few things to keep in mind though:</p>
<br>
<ul>
<li>The larger the project, the longer it will take to complete</li>
<li>The more complex the language, the more complex the compiler</li>
<li>The less planning ahead you do, the more scurrying around you will do</li>
</ul>
<br>
<p>Writing a compiler is very rewarding, and can be very fun. Just know that, like
with any project, knowing what it is that you are getting yourself into is very
important, and makes sure you don't loose sight of the end goal.</p>
<br>
<p>If you decide to make your own programming language, understand that not only
are you writing a compiler, but you are also designing a language: You need to
figure out the syntax, the structure, how it is all going to "fit together".</p>
<br>
<h2>What is a Compiler?</h2>
<br>
<p>Basically, a compiler is something that takes in data (code, files, user input,
etc), manipulates it, and spits out some sort of result (binary/executable, an
image, code, etc). All compilers are written differently, as they do
different things, have different requirements and goals, and are built by
different people.</p>
<br>
<p>Compilers come in all sorts of shapes and sizes. Here are some examples:</p>
<br>
<p><strong><a href="https://gcc.gnu.org/">GCC</a>/<a href="https://clang.llvm.org/">Clang</a></strong>:
These are very big compilers, capable of compiling many different
programming languages, primarily C and C++.
They are very mature, and do a lot of the heavy lifting for you in terms
of platform and hardware support, optimizations, and performance.</p>
<br>
<p><strong><a href="https://esbuild.github.io/">esbuild</a></strong>:
Esbuild is "an extremely fast JavaScript bundler", as stated on
their website. Basically, it takes in JavaScript, and spits out JavaScript.
This is an example of a source-to-source compiler, since it takes in, and
spits out source code.</p>
<br>
<p><strong><a href="https://github.com/dosisod/dosisod.github.io">My blog site</a></strong>:
All of my blogs are written in markdown, and converted to
HTML, which allows for easily writing blogs without the hassle of writing
the HTML myself (or having to change a bunch of HTML when I want to have
a different layout).</p>
<br>
<p>With all that being said, most compilers are split up into different chunks,
which we will see below.</p>
<br>
<h2>Parts of a Compiler</h2>
<br>
<h3>The Front End</h3>
<br>
<p>This is the part of the compiler that you will interact with most often.
It is responsible for taking in the code you give it, parsing it, and sending
it off to the next stages of the compiler. To make things easier, the data
from the file is parsed into a tree-like structure called an AST (abstract
syntax tree). Most compiler front ends do these steps:</p>
<br>
<ul>
<li><strong>Tokenization</strong>: Split code into little "tokens", for example, each word or operator</li>
<li><strong>Classification</strong>: Each token is assigned a type based on it's contents</li>
<li><strong>AST Generation</strong>: The tokens are grouped up into meaningful "nodes", which represent different parts of the program (ie, a variable definition, or function call)</li>
</ul>
<br>
<h3>The Middle End</h3>
<br>
<p>This is where the AST is checked for symantic errors, (including type
checking), and optionally, optimization(s) are performed. This is where the
"juicy" parts of most compilers live. The job of the middle end is to make sure
that the parsed code is valid, and make sure that the optimizations are done
such that the backend can only worry about what it needs to do.</p>
<br>
<h3>The Back End</h3>
<br>
<p>After the AST has been checked, the backend will start to generate the
executable (or code). There are many techniques that a backend can use to
generate these files, which we won't get into right now. Some might compilers
only have one backend, while others might support many different backens.
This all depends on the wants and needs of the language designer.</p>
<br>
<h2>The Next Steps</h2>
<br>
<p>At the end of this series, we will have created a simple programming language
in Python, which supports 2 backends: a Python backend, and an <a href="https://llvm.org/">LLVM</a>
backend, which allows for building executables, and JIT compilation of out code.</p>
<br>
<main>

</body>
</html>
