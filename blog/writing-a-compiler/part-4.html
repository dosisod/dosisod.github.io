<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="" />
  <meta name="og:title" content="Writing a Compiler (Part 4): Designing the Language" />
  <link rel="stylesheet" href="/styles/main.css">
  <link rel="stylesheet" href="/styles/github.css" />
  <title>Writing a Compiler (Part 4): Designing the Language</title>
</head>
<body>

<main>
<a id="writing-a-compiler-part-4-designing-the-language" href="#writing-a-compiler-part-4-designing-the-language"><h1>Writing a Compiler (Part 4): Designing the Language</h1></a>
<br>
<p>One of the first things you do when you build a programming language is you
figure out what you want it to look like: How is it going to <em>feel</em>? What do
you want the code to <em>look</em> like? What <a href="https://en.wikipedia.org/wiki/Programming_paradigm">paradigm</a>
will it be in? What differentiates your language from the rest?</p>
<br>
<p>When you are making your first language, it is a lot easier to take from an existing language,
since they have gone through all the hard work of designing it for you.</p>
<br>
<p>For this series, we will create an <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/tour">F#</a>-like
language. It won&#x27;t have all of the fancy frills, just the bare minimum for us to call it
a &quot;real&quot; programming language, something that is actually &quot;useful&quot;.</p>
<br>
<blockquote>For the purposes of our language, we will consider &quot;useful&quot; as being able to communicate with
a C library. Any feature that our language cannot support, a C function could be created as a work-around.</blockquote>
<br>
<p>The reason I am choosing F# is it is a very simple, functional language. The language constructs
we need to support are very small, and the parsing of F# (and similar functional languages) is pretty
straight-forward.</p>
<br>
<a id="what-we-are-going-to-build" href="#what-we-are-going-to-build"><h2>What We Are Going To Build</h2></a>
<br>
<p>Although subject to change, this the basic functionality which our language will support:</p>
<br>
<pre class="hljs"><span class="hljs-comment">// This is a comment!</span>

<span class="hljs-keyword">let</span> num <span class="hljs-operator">=</span> <span class="hljs-number">123</span>
<span class="hljs-keyword">let</span> pi<span class="hljs-operator">:</span> <span class="hljs-type">double</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415</span>

println <span class="hljs-string">&quot;Hello, World!&quot;</span>

<span class="hljs-keyword">let</span> square x <span class="hljs-operator">=</span> x <span class="hljs-operator">*</span> x
<span class="hljs-keyword">let</span> addN x y <span class="hljs-operator">=</span> x <span class="hljs-operator">+</span> y

<span class="hljs-keyword">let</span> chainExample <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <span class="hljs-operator">|&gt;</span> square <span class="hljs-operator">|&gt;</span> addN <span class="hljs-number">2</span>

<span class="hljs-keyword">let</span> intTuple <span class="hljs-operator">=</span> (<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)

<span class="hljs-keyword">if</span> num <span class="hljs-operator">=</span> <span class="hljs-number">123</span> <span class="hljs-keyword">then</span>
  println <span class="hljs-string">&quot;num is 123&quot;</span>
<span class="hljs-keyword">else</span>
  println <span class="hljs-string">&quot;num is not 123&quot;</span>

<span class="hljs-meta">[&lt;Import(<span class="hljs-string">&quot;libwhatever.so&quot;</span>)&gt;]</span>
<span class="hljs-keyword">extern</span> cFunc()
cFunc ()

<span class="hljs-keyword">module</span> m <span class="hljs-operator">=</span>
  <span class="hljs-keyword">let</span> helloWorld () <span class="hljs-operator">=</span> println <span class="hljs-string">&quot;Hello, world!&quot;</span>

m.helloWorld ()</pre>

<br>
<p>So now what?</p>
<br>
<a id="breaking-it-down" href="#breaking-it-down"><h2>Breaking It Down</h2></a>
<br>
<p>Basically, we need to break up these lines of code into statements and expressions.
An expression is something that returns a value, such as a numeric literal, a function call,
or a variable. A statement is something that doesn&#x27;t return a value, like a variable declaration,
module declaration, if statement, and so on.</p>
<br>
<blockquote>F# <em>does</em> actually support <code class="hljs">if</code> statements which
return an expression, basically making it a ternary operator. We probably won&#x27;t support this,
though that might change in the future.</blockquote>
<br>
<a id="expressions" href="#expressions"><h3>Expressions</h3></a>
<br>
<p>Let&#x27;s start by defining what an expression is. Expressions are at the heart of all programming
languages, and are one of the hardest part to get right. An expression node will (probably)
have the following fields:</p>
<br>
<p><em>Expression Node</em>:</p>
<br>
<table><tr><th>Field</th><th>Type</th><th>Description</th></tr><tr><td><code class="hljs">lhs</code></td><td><code class="hljs">Expression</code> (optional)</td><td>Left-hand-side of expression (in the case of binary/unary operator)</td></tr><tr><td><code class="hljs">rhs</code></td><td><code class="hljs">Expression</code> (optional)</td><td>Right-hand-side of expression (same as <code class="hljs">lhs</code>)</td></tr><tr><td><code class="hljs">oper</code></td><td><code class="hljs">ExpressionOperator</code></td><td>The operator that this expression is (ie, <code class="hljs">+</code>, <code class="hljs">-</code>, <code class="hljs">FuncCall</code>, <code class="hljs">Literal</code></td></tr><tr><td><code class="hljs">value</code></td><td><code class="hljs">Any</code> (optional)</td><td>Value of the expression, in the case of a terminal expression, such as a literal</td></tr><tr><td><code class="hljs">type</code></td><td>TBD</td><td>Type of the expression</td></tr></table>
<br>
<p>The <code class="hljs">lhs</code> and <code class="hljs">rhs</code> are only needed for binary operators, such as <code class="hljs">+</code>, <code class="hljs">-</code>, and so on. In the example below:</p>
<br>
<pre class="hljs">(1 + 2) * 3 + 4</pre>
<br>
<p>We would get an expression tree somewhat similar to this:</p>
<br>
<pre class="hljs">
         +
        / \
       *   4
      / \
     +   3
    / \
   1   2
</pre>
<br>
<p>As you can see, nodes <code class="hljs">1</code>, <code class="hljs">2</code>, <code class="hljs">3</code>, and <code class="hljs">4</code> are all terminal nodes (have no child nodes), meaning they will
have a <code class="hljs">value</code> set. The <code class="hljs">+</code> and <code class="hljs">*</code> nodes have a lhs/rhs, so those fields will be set respectively.</p>
<br>
<a id="statements" href="#statements"><h3>Statements</h3></a>
<br>
<p>These next few nodes are pretty simple, so I will go thought them all at once:</p>
<br>
<p><strong>Variable Declaration Node</strong>:</p>
<br>
<table><tr><th>Field</th><th>Type</th></tr><tr><td><code class="hljs">name</code></td><td><code class="hljs">str</code></td></tr><tr><td><code class="hljs">expr</code></td><td><code class="hljs">Expression</code></td></tr></table>
<br>
<p><strong>External Declaration Node</strong>:</p>
<br>
<table><tr><th>Field</th><th>Type</th></tr><tr><td><code class="hljs">name</code></td><td><code class="hljs">str</code></td></tr><tr><td><code class="hljs">type</code></td><td>TBD</td></tr></table>
<br>
<p><strong>Module Declaration Node</strong>:</p>
<br>
<table><tr><th>Field</th><th>Type</th><th>Description</th></tr><tr><td><code class="hljs">name</code></td><td><code class="hljs">str</code></td><td></td></tr><tr><td><code class="hljs">stmts</code></td><td><code class="hljs">List[Statement]</code></td><td>List of statements that make up this module</td></tr></table>
<br>
<p>There will also have to be a <code class="hljs">Statement</code> type which includes variable, external data, and module
declarations (that way the <code class="hljs">Module</code> node can have a list of sub modules/variables etc).</p>
<br>
<a id="that-x27-s-it" href="#that-x27-s-it"><h2>That&#x27;s It!</h2></a>
<br>
<p>Really this blog has been just a stepping stone, something to help lay the groundwork for the next
few blogs.</p>
<br>
<p>Next time, we will actually flesh out these node objects, and start to turn our token stream into
AST nodes!</p>
<br>
<p>[<a href="./part-3.html">prev</a>]
[<a href="./part-5.html">next</a>]</p>
<hr>

<script src="https://utteranc.es/client.js"
  repo="dosisod/dosisod.github.io"
  issue-term="title"
  theme="github-light"
  crossorigin="anonymous"
  async>
</script>

<noscript>
  <br>
  <em>
    Comment with GitHub functionality is
    disabled when JavaScript is turned off.
  </em>
</noscript>

</main>

</body>
</html>
