<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="" />
  <meta name="og:title" content="NPM: Not Much Performance" />
  <link rel="stylesheet" href="/styles/main.css">
  <link rel="stylesheet" href="/styles/github.css" />
  <title>NPM: Not Much Performance</title>
</head>
<body>

<main>
<a id="npm-not-much-performance" href="#npm-not-much-performance"><h1>NPM: Not Much Performance</h1></a>
<br>
<p>This blog is about how slow JavaScript is, and how certain maintainers have resorted
to writing faster tools in Rust, Zig, and Golang, instead of JavaScript <a id="footnote-ref-1" href="#footnote-1">[1]</a>. I find it ironic
that NPM is being used distribute binary blobs given that NPM is a JavaScript ecosystem <a id="footnote-ref-2" href="#footnote-2">[2]</a>.</p>
<br>
<p>Here are a few examples:</p>
<br>
<ul>
<li><a href="https://swc.rs/">SWC</a>: A TypeScript/JavaScript compiler written in Rust</li>
<li><a href="https://esbuild.github.io/">esbuild</a>: A JavaScript bundler written in Golang</li>
<li><a href="https://parceljs.org/">Parcel</a>: Another JavaScript bundler written in Rust</li>
<li><a href="https://www.npmjs.com/package/snappy">Snappy</a>: A fast compression library written with <a href="https://napi.rs/">NAPI-RS</a> (Rust)</li>
</ul>
<br>
<p>Note how most of these are tooling focused: Most are targeted at compilers, which
will be used by your bundlers, type-checkers, and transpilers (<a href="https://vitejs.dev/">Vite</a> is a popular
example of this).</p>
<br>
<p>The reason we are seeing a emphasis on faster tooling is because these fast binaries serve
no purpose to the end user: You can&#x27;t deploy a Rust/Go/Zig binary to the user.
Another reason is because NodeJS is still the primary server-side JavaScript framework:
Frameworks like <a href="https://deno.land/">Deno</a> and <a href="https://bun.sh/">Bun</a> have yet to take off,
and catering to the largest audience, NodeJS, makes the most sense for most tool-makers.
Lastly, there is a plethora of software on NPM, not all of which is supported in Deno/Bun.</p>
<br>
<a id="will-there-be-a-future-without-javascript" href="#will-there-be-a-future-without-javascript"><h2>Will There Be A Future Without JavaScript?</h2></a>
<br>
<p>Hardly. Some will say C, Java, Visual Basic, and FORTRAN are dead languages, but there is
plenty of depended-on code written in these languages, and they won&#x27;t be going away anytime
soon <a id="footnote-ref-3" href="#footnote-3">[3]</a>.</p>
<br>
<p>Sometimes people don&#x27;t care about performance, and (sometimes) that is fine! Worry about
building good software that serves a purpose, don&#x27;t make fast software that goes nowhere.</p>
<br>
<hr>
<br>
<p><a id="footnote-1" href="#footnote-ref-1">[1]</a>: Yes, I know: JavaScript is a language. NodeJS is a runtime, and NPM is a package
manager. They are often used together, but not all JavaScript code comes from NPM, and
not all JavaScript is executed using NodeJS. Still, NodeJS remains the biggest framework out
there, and that is the ecosystem I will be talking about today.</p>
<br>
<p><a id="footnote-2" href="#footnote-ref-2">[2]</a>: Also, some alarm bells should be going off at the thought of any ole&#x27; NPM package
being able to plop a malicious executable on your machine. I don&#x27;t know if there is any
automated scanning of NPM packages, but I doubt there is.</p>
<br>
<p><a id="footnote-3" href="#footnote-ref-3">[3]</a>: C and Java will never die. C is used in more places then you might think, and Java is
taught far and wide, and will never not be talked about. Until Kotlin takes over the world,
perhaps.</p>
<hr>

<script src="https://utteranc.es/client.js"
  repo="dosisod/dosisod.github.io"
  issue-term="title"
  theme="github-light"
  crossorigin="anonymous"
  async>
</script>

<noscript>
  <br>
  <em>
    Comment with GitHub functionality is
    disabled when JavaScript is turned off.
  </em>
</noscript>

</main>

</body>
</html>
